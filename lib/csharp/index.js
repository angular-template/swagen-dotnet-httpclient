'use strict';

const _ = require('lodash');

const swagenCore = require('swagen-core');
const getDataType = require('./get-data-type');

module.exports = class Generator {
    constructor(definition, profile) {
        this.definition = definition;
        this.profile = profile;
        this.transform = new swagenCore.transformer.Transformer(profile);
    }

    generate() {
        this.code = new swagenCore.CodeBuilder();
        this.generateInitialCode();
        this.code.blank();
        this.generateInterfaces();
        this.code.blank();
        this.generateImplementations();
        this.code.blank();
        this.generateModels();
        return this.code.toCode();
    }

    generateInitialCode() {
        this.code.line(
            `//------------------------------`,
            `// <auto-generated>`,
            `//     Generated using the swagen tool`,
            `//     Generator: dotnet-httpclient`,
            `//     Mode: csharp`,
            `// </auto-generated>`,
            `//------------------------------`
        );
        if (this.definition.metadata.title) {
            this.code.line(`// ${this.definition.metadata.title}`);
        }
        if (this.definition.metadata.description) {
            this.code.line(`// ${this.definition.metadata.description}`);
        }
        if (this.definition.metadata.baseUrl) {
            this.code.line(`// Base URL: ${this.definition.metadata.baseUrl}`);
        }

        this.code.blank();

        this.code.line(
            `using System;`,
            `using System.Collections.Generic;`,
            `using System.Net.Http;`,
            `using System.Threading.Tasks;`,
            ``,
            `using __models = ${this.profile.options.namespaces.models};`
        );
    }

    generateInterfaces() {
        this.code.line(
            `namespace ${this.profile.options.namespaces.services}`,
            `{`
        ).indent();
        let sortedKeys = _.keys(this.definition.services).sort();
        for (let i = 0; i < sortedKeys.length; i++) {
            let serviceName = sortedKeys[i];
            let service = this.definition.services[serviceName];
            let transformedServiceName = this.transform.serviceName(serviceName, {
                service: service
            }) + (this.profile.options.serviceSuffix || 'Client');
            this.code.line(
                `public interface I${transformedServiceName}`,
                `{`
            ).indent();

            for (let operationName in service) {
                let operation = service[operationName];
                let transformedOperationName = this.transform.operationName(operationName, {
                    transformedServiceName: transformedServiceName,
                    serviceName: serviceName,
                    service: service
                });

                if (operation.description || operation.description2) {
                    this.code
                        .line(`/// <summary>`)
                        .lineIf(!!operation.description, `/// ${operation.description}`)
                        .lineIf(!!operation.description2, `/// ${operation.description2}`)
                        .line(`/// </summary>`);
                }
                this.code.repeat((operation.parameters || []).filter(p => !!p.description), (cb, param, i) => {
                    cb.line(`/// <param name="${param.name}">${param.description}</param>`);
                });
                this.code.line(
                    `${this.getMethodSignature(transformedOperationName, operation)};`
                );
                this.code.blank();
            }
            this.code.unindent().line('}');
            this.code.blank();
        }
        this.code.unindent().line('}');
    }

    generateImplementations() {
        let baseUrl = this.profile.options.baseUrl;
        let baseUrlVariable = baseUrl.variable || _.camelCase(baseUrl.provider);
        let baseUrlPath = baseUrl.path ? baseUrlVariable + '.' + baseUrl.path.join('.') : baseUrlVariable;

        this.code.line(
            `namespace ${this.profile.options.namespaces.services}`,
            `{`
        ).indent();

        let sortedKeys = _.keys(this.definition.services).sort();
        for (let i = 0; i < sortedKeys.length; i++) {
            let serviceName = sortedKeys[i];
            let service = this.definition.services[serviceName];
            let transformedServiceName = this.transform.serviceName(serviceName, {
                service: service
            }) + (this.profile.options.serviceSuffix || 'Client');

            this.code.line(
                `public sealed class ${transformedServiceName} : I${transformedServiceName}`,
                `{`
            ).indent();

            for (let operationName in service) {
                let operation = service[operationName];
                let transformedOperationName = this.transform.operationName(operationName, {
                    transformedServiceName: transformedServiceName,
                    serviceName: serviceName,
                    service: service
                });

                this.code.line(
                    `${this.getMethodSignature(transformedOperationName, operation, transformedServiceName)}`,
                    `{`
                ).indent();

                //Check required parameters
                let requiredParams = (operation.parameters || []).filter(p => !!p.required && (p.dataType.complex || !!p.dataType.isArray || p.dataType.primitive === 'string'));
                this.code.repeat(requiredParams, (cb, requiredParam) => {
                    cb.line(
                        `if (${requiredParam.name} == null)`,
                        `    throw new ArgumentNullException(nameof(${requiredParam.name}));`
                    );
                });

                //Resolve path parameters in relative URL.
                let pathParams = (operation.parameters || []).filter(p => p.type === 'path');
                this.code
                    .inline(`string resourceUrl = "${operation.path}"`)
                    .inline(`;`, pathParams.length === 0)
                    .done();
                this.code.indent();
                this.code.repeat(pathParams, (cb, pathParam, i) => {
                    cb
                        .inline(`.Replace("{${pathParam.name}}", Uri.EscapeString(${pathParam.name}.ToString()))`)
                        .inline(`;`, i >= pathParams.length - 1)
                        .done();
                });
                this.code.unindent();

                //Query parameters
                let queryParams = (operation.parameters || []).filter(p => p.type === 'query');
                if (queryParams.length > 0) {
                    this.code.line(
                        `var queryParams = new Dictionary<string, string> {`
                    ).indent();
                    for (let i = 0; i < queryParams.length; i++) {
                        this.code
                            .inline(`[${queryParams[i].name}] = ${queryParams[i].name}`)
                            .inline(`,`, i < queryParams.length)
                            .done();
                    }
                    this.code.unindent().line(`};`)
                }

                let returnType = this.getReturnType(operation);

                this.code
                    .inline(`string serviceUrl = ServiceUrl.Build(${this.profile.options.baseUrl}, resourceUrl`)
                    .inline(`, queryParams`, queryParams.length > 0)
                    .inline(`);`)
                    .done();
                this.code
                    .line(`var request = new HttpRequestMessage(HttpMethod.${_.upperFirst(_.camelCase(operation.verb))}, serviceUrl) {`).indent()
                    .unindent().line(`}`);
                if (returnType) {
                    this.code.line(
                        `HttpResponseMessage response = await HttpClientFactory.Instance.SendAsync(request);`,
                        `${returnType} result = await response.Content.ReadAsAsync<${returnType}>();`,
                        `return result;`
                    );
                } else {
                    this.code.line(
                        `HttpResponseMessage response = await HttpClientFactory.Instance.SendAsync(request);`
                    );
                }
                this.code.unindent().line(`}`);
                this.code.blank();
            }

            //Class closing
            this.code.unindent().line(`}`);
            this.code.blank();
        }

        this.generateBuildUrlFunction();
        this.code.blank();
        this.generateHttpClientSingleton();

        //Namespace closing
        this.code.unindent().line(`}`);
    }

    getReturnType(operation) {
        if (!operation.responses) {
            return undefined;
        }

        for (let statusKey in operation.responses) {
            let statusCode = +statusKey;
            if (statusCode >= 200 && statusCode < 300 && operation.responses[statusKey].dataType) {
                return getDataType(operation.responses[statusKey].dataType, undefined);
            }
        }

        return undefined;
    }

    getMethodSignature(operationName, operation, serviceName) {
        let orderedParams = (operation.parameters || []).filter(p => p.required).concat(
            (operation.parameters || []).filter(p => !p.required)
        );
        let parameters = '';
        for (let p = 0; p < orderedParams.length; p++) {
            let parameter = orderedParams[p];
            if (parameters) {
                parameters += ', '
            }
            parameters += `${getDataType(parameter.dataType, parameter.name, this.profile.options.namespaces.models)} ${parameter.name}`;
        }

        let returnType = this.getReturnType(operation);
        let taskReturnType = returnType ? `Task<${returnType}>` : 'Task';

        if (serviceName) {
            return `async ${taskReturnType} I${serviceName}.${operationName}(${parameters})`
        }
        return `${taskReturnType} ${operationName}(${parameters})`;
    }

    generateBuildUrlFunction() {
        this.code.line(
            `internal static class ServiceUrl`,
            `{`,
            `    internal static string Build(string baseUrl, string resourceUrl, queryParams: IDictionary<string, string> = null)`,
            `    {`,
            `        string url = baseUrl;`,
            `        bool baseUrlSlash = url.EndsWith("/");`,
            `        bool resourceUrlSlash = resourceUrl.StartsWith("/");`,
            `        if (!baseUrlSlash && !resourceUrlSlash)`,
            `            url += "/";`,
            `        else if (baseUrlSlash && resourceUrlSlash)`,
            `            url = url.Substring(0, url.Length - 1);`,
            `        url += resourceUrl;`,
            ``,
            `        if (queryParams != null) {`,
            `            bool isFirst = true;`,
            `            foreach (var kvp in queryParams) {`,
            `                char separator = isFirst ? '?' : '&';`,
            `                url += $"{separator}{kvp.Key}={Uri.EscapeString(kvp.Value)}";`,
            `                isFirst = false;`,
            `            }`,
            `        }`,
            `        return url;`,
            `    }`,
            `}`
        );
    }

    generateHttpClientSingleton() {
        this.code.line(
            `internal static class HttpClientFactory`,
            `{`,
            `    internal static HttpClient Instance { get; } = new HttpClient();`,
            `}`
        );
    }

    generateModels() {
        this.code.line(
            `namespace ${this.profile.options.namespaces.models}`,
            `{`
        ).indent();

        let sortedKeys = _.keys(this.definition.models).sort((x, y) => x.toLowerCase().localeCompare(y.toLowerCase()));

        for (let i = 0; i < sortedKeys.length; i++) {
            let modelName = sortedKeys[i];
            let model = this.definition.models[modelName];
            this.code.line(
                `public sealed class ${modelName}`,
                `{`
            ).indent();

            for (let propertyName in model) {
                let property = model[propertyName];
                let transformedPropertyName = this.transform.propertyName(propertyName, {
                    property: property,
                    model: model
                });
                this.code.line(
                    `[JsonProperty("${propertyName}")]`,
                    `public ${getDataType(property, propertyName, true)} ${transformedPropertyName};`
                );
                this.code.blank();
            }

            // End of class
            this.code.unindent().line(`}`);
        }

        // End of namespace
        this.code.unindent().line(`}`);
    }
}
